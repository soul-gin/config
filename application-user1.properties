eureka.client.service-url.defaultZone=http://euk1.com:7001/eureka/

server.port=94

spring.application.name=user-consumer

#配置请求GZIP压缩
feign.compression.request.enabled=true
#配置响应GZIP压缩
feign.compression.response.enabled=true
#单位是B
feign.compression.request.min-request-size=100

#连接超时时间(ms)
ribbon.ConnectTimeout=1000
#业务逻辑超时时间(ms)
ribbon.ReadTimeout=2000

#同一台实例最大重试次数,不包括首次调用
ribbon.MaxAutoRetries=1
#重试负载均衡其他的实例最大重试次数,不包括首次调用
# 1. 一个实例调用判断超时
#           -> 记录该次失败(6s内不再调用该实例)
# 2. 尝试向其他实例发起请求
ribbon.MaxAutoRetriesNextServer=1
#是否所有操作都重试
ribbon.OkToRetryOnAllOperations=false

# 设计 hystrix



# 熔断(失败,重试,多次失败后就不调用该实例了)
# 1. 一个实例调用判断超时
#           -> 记录该次失败(6s内不再调用该实例)
# 2. 尝试向其他实例发起请求


# 降级 不进行调用,直接返回fallback
# 阈值
# 计算连续失败次数达到阈值
# 则 请求/不请求/半请求(开/关/半开)
# 一定时间后,恢复

# 隔离(调用时,请求不同服务之间的隔离)
# 消费端向服务端调用,使用http请求,需要消耗线程
# map.put(URI, 线程数)
# (线程池(线程数))


# 让失败情况下hystrix会处理
feign.hystrix.enabled=true

# 隔离策略，默认是Thread, 可选Thread｜Semaphore (线程池隔离,信号量隔离)
# Thread 适合IO密集型,等待IO耗时严重,这时候通过新建线程池,异步处理
# (不同的服务请求分配不同线程池,线程数量达到线程池阈值则拒绝
# 等待时间长的线程池大小小一点;等待时间短的线程池大小大一点;)
# 优势: 线程池拒绝策略(4种), 异步失败不影响work线程
# tomcat需要配置work异步(类似IO多路复用),压榨系统性能(阻塞,注册回调至work线程,
# work可以继续处理其他请求(异步事件处理完后回调work再返回给客户))
# 劣势:消耗资源(要创建线程池,异步处理)

# Semaphore 适合计算密集型,类似令牌桶(通过计数方式,count--;当count=0时则拒绝用户请求)
# 优势: 相对消耗资源少(不创建线程池)
# 劣势: 无法复用work,需要IO等待
hystrix.command.default.execution.isolation.strategy=Thread

# 开启 actuator 所有节点信息上报, 查看 dashboard
# 查看健康上报
# http://localhost:94/actuator/hystrix.stream
# 图形化
# http://localhost:94/hystrix  输入监控地址:http://localhost:94/actuator/hystrix.stream
management.endpoints.web.exposure.include=*

# zipkin 下载: https://zipkin.io/pages/quickstart.html
# 运行:java -jar zipkin.jar 端口:9411
# http://localhost:9411/ 是zipkin的取样地址,接口调用数据上传至9411,再通过图形界面展示
#spring.zipkin.base-url=http://localhost:9411/
# 采样比例1
#spring.sleuth.sampler.rate=1

# 开启 actuator 所有节点信息上报, admin需配置
#management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always
spring.boot.admin.client.url=http://localhost:8080


# 注意: 需要将 application.properties 重命名为 bootstrap.properties (加载优先级高于 application.properties)
# 那么会先从远程拉取配置之后,再创建对象(否则使用了远程配置文件的属性会创建bean失败)
# 直接URL方式查找配置中心
spring.cloud.config.uri=http://localhost:9999/

#通过注册中心查找
#spring.cloud.config.discovery.enabled=true
#spring.cloud.config.discovery.service-id=config

# 类似 active profiles = user1
spring.cloud.config.profile=user1
# git使用哪条分支
spring.cloud.config.label=master

config.info="config-master,v1"